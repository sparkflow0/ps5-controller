<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>PS5 Controller Configurator â€“ Mask-based Picking</title>
  <style>
    :root {
      --bg: #151515;
    }

    /* Global reset + mobile tap highlight removal */
    * {
      box-sizing: border-box;
    }

    html,
    body,
    .controller-wrapper,
    .controller-area,
    button,
    .swatch {
      -webkit-tap-highlight-color: transparent !important;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: radial-gradient(circle at top, #05060b 0, #020308 50%, #000 100%);
      color: #fff;
      overflow: hidden;
    }

    /* Background canvas for sci-fi lines (desktop only; disabled on mobile via JS) */
    #bgCanvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      pointer-events: none;
      display: block;
    }

    /* Remove focus outlines */
    button,
    button:focus,
    button:active,
    .swatch,
    .swatch:focus,
    .swatch:active,
    .controller-area:focus,
    .controller-area:active,
    .controller-wrapper:focus,
    .controller-wrapper:active,
    img:focus,
    img:active {
      outline: none;
    }

    button {
      border: none;
      background: none;
      -webkit-appearance: none;
      appearance: none;
    }

    /* Wrapper with no background, radius, or shadow */
    .controller-wrapper {
      padding: 16px;
      position: relative;
      overflow: visible;
      max-width: 1166px;
      /* controller PNG width */
      width: 90vw;
    }

    .controller-area {
      position: relative;
      width: 100%;
      aspect-ratio: 1166 / 768;
      /* controller PNG ratio */
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      touch-action: manipulation;
    }

    .controller-area img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      user-select: none;
      pointer-events: none;
      filter: drop-shadow(0 18px 28px rgba(0, 0, 0, 0.8));
    }

    /* Masked color layers (visual only) */
    .part-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .part-layer::before {
      content: "";
      position: absolute;
      inset: 0;

      /* brighter, more vivid color layer */
      background: var(--tint, transparent);
      filter: brightness(1.45) saturate(1.4) contrast(1.05);

      /* blend mode that brightens instead of darkens */
      mix-blend-mode: overlay;

      /* slightly higher opacity for stronger tint */
      opacity: 1;

      -webkit-mask-image: var(--mask-url);
      mask-image: var(--mask-url);
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      -webkit-mask-size: contain;
      mask-size: contain;
      -webkit-mask-position: center;
      mask-position: center;
    }

    /* Mask-shaped glow when selected */
    .part-layer.selected::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at center,
          rgba(255, 255, 255, 0.9),
          rgba(255, 255, 255, 0) 60%);
      -webkit-mask-image: var(--mask-url);
      mask-image: var(--mask-url);
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      -webkit-mask-size: contain;
      mask-size: contain;
      -webkit-mask-position: center;
      mask-position: center;
      mix-blend-mode: screen;
      filter:
        drop-shadow(0 0 12px rgba(255, 255, 255, 0.9)) drop-shadow(0 0 22px rgba(0, 0, 0, 0.9));
      opacity: 0.7;
      animation: breathe 1.8s ease-in-out infinite;
      pointer-events: none;
    }

    @keyframes breathe {

      0%,
      100% {
        opacity: 0.55;
        transform: scale(1);
      }

      50% {
        opacity: 1;
        transform: scale(1.03);
      }
    }

    .part-layer.apply-flash::before {
      animation: applyFlash 0.45s ease-out;
    }

    @keyframes applyFlash {
      0% {
        filter: brightness(2.5) saturate(1.4);
      }

      100% {
        filter: brightness(1) saturate(1);
      }
    }

    /* ---------- Fixed palette bar under the controller ---------- */

    .palette-container {
      margin-top: 18px;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      gap: 14px;
      opacity: 0;
      transform: translateY(12px);
      pointer-events: none;
      transition: opacity 0.22s ease, transform 0.22s ease;
    }

    .palette-container.visible {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    .swatch {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.25);

      /* Strong 3D feel: outer + inner shadows */
      box-shadow:
        /* outer drop shadow */
        0 18px 30px rgba(0, 0, 0, 0.9),
        0 6px 12px rgba(0, 0, 0, 0.85),
        /* main inner dark ring */
        0 0 0 2px rgba(0, 0, 0, 0.95) inset,
        0 10px 18px rgba(0, 0, 0, 0.95) inset,
        /* top inner highlight rim */
        0 -4px 8px rgba(255, 255, 255, 0.45) inset;

      background-image:
        /* glossy highlight at top-left */
        radial-gradient(circle at 28% 24%,
          rgba(255, 255, 255, 0.75),
          rgba(255, 255, 255, 0.1) 42%,
          rgba(255, 255, 255, 0) 60%),
        /* soft sheen bottom-right */
        radial-gradient(circle at 76% 80%,
          rgba(255, 255, 255, 0.18),
          rgba(0, 0, 0, 0.5) 65%,
          rgba(0, 0, 0, 0.85) 100%);

      /* Same enhancement filter as controller tint */
      filter: brightness(1.45) saturate(1.4) contrast(1.05);

      opacity: 0;
      transform: scale(0.6);
      animation: swatch-pop 0.22s cubic-bezier(0.22, 0.9, 0.25, 1) forwards;
      transition: transform 0.16s ease, box-shadow 0.16s ease, filter 0.16s ease;
    }

    .swatch.gold-rim {
      box-shadow:
        0 20px 34px rgba(0, 0, 0, 0.95),
        0 8px 14px rgba(0, 0, 0, 0.9),
        0 0 0 2px rgba(0, 0, 0, 1) inset,
        0 10px 20px rgba(0, 0, 0, 0.98) inset,
        0 -4px 10px rgba(255, 255, 255, 0.5) inset,
        0 0 0 2px rgba(255, 215, 128, 0.98),
        0 0 18px rgba(255, 230, 160, 0.9),
        0 0 16px rgba(255, 255, 255, 0.85) inset;
    }

    .swatch:hover {
      transform: scale(1.08);
      box-shadow:
        0 24px 40px rgba(0, 0, 0, 1),
        0 10px 18px rgba(0, 0, 0, 0.95),
        0 0 0 2px rgba(0, 0, 0, 1) inset,
        0 12px 22px rgba(0, 0, 0, 1) inset,
        0 -5px 10px rgba(255, 255, 255, 0.6) inset;
      /* Boost the same look a bit on hover */
      filter: brightness(1.6) saturate(1.6) contrast(1.08);
    }

    @keyframes swatch-pop {
      0% {
        opacity: 0;
        transform: scale(0.3);
      }

      60% {
        opacity: 1;
        transform: scale(1.05);
      }

      100% {
        opacity: 1;
        transform: scale(1);
      }
    }
  </style>
</head>

<body>
  <!-- Sci-fi glowing lines background (desktop only, disabled on mobile in JS) -->
  <canvas id="bgCanvas"></canvas>

  <div class="controller-wrapper">
    <div class="controller-area" id="controllerArea">
      <img src="controller.png" alt="PS5 Controller" />

      <!-- Masked layers for tint and highlight -->
      <div class="part-layer" data-part-id="leftShell" style="--mask-url: url('masks/leftShell.png');"></div>
      <div class="part-layer" data-part-id="rightShell" style="--mask-url: url('masks/rightShell.png');"></div>
      <div class="part-layer" data-part-id="centerBody" style="--mask-url: url('masks/centerBody.png');"></div>
      <div class="part-layer" data-part-id="touchpad" style="--mask-url: url('masks/touchpad.png');"></div>
      <div class="part-layer" data-part-id="bumperL" style="--mask-url: url('masks/bumperL.png');"></div>
      <div class="part-layer" data-part-id="bumperR" style="--mask-url: url('masks/bumperR.png');"></div>
      <div class="part-layer" data-part-id="dpad" style="--mask-url: url('masks/dpad.png');"></div>
      <div class="part-layer" data-part-id="faceButtons" style="--mask-url: url('masks/faceButtons.png');"></div>
      <div class="part-layer" data-part-id="share" style="--mask-url: url('masks/share.png');"></div>
      <div class="part-layer" data-part-id="options" style="--mask-url: url('masks/options.png');"></div>
      <div class="part-layer" data-part-id="stickL" style="--mask-url: url('masks/stickL.png');"></div>
      <div class="part-layer" data-part-id="stickR" style="--mask-url: url('masks/stickR.png');"></div>
      <div class="part-layer" data-part-id="psButton" style="--mask-url: url('masks/psButton.png');"></div>
      <div class="part-layer" data-part-id="speaker" style="--mask-url: url('masks/speaker.png');"></div>
    </div>

    <!-- Fixed color palette centered under the controller -->
    <div class="palette-container" id="paletteContainer"></div>
  </div>

  <script>
    /* ---------- Mobile detection ---------- */
    const isMobile =
      /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) ||
      window.innerWidth < 768;

    /* ---------- Sci-fi diagonal glowing zigzag lines background (desktop only) ---------- */
    (function () {
      const canvas = document.getElementById("bgCanvas");

      // If mobile: disable the animated background completely to avoid lag
      if (isMobile) {
        canvas.style.display = "none"; // static CSS gradient background only
        return;
      }

      const ctx = canvas.getContext("2d");

      let width = window.innerWidth;
      let height = window.innerHeight;

      function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
      }
      resize();
      window.addEventListener("resize", resize);

      // Soft neon sci-fi palette, low opacity for base stroke, stronger for glow
      const LINE_COLORS = [
        { stroke: "rgba(0, 255, 255, 0.08)", glow: "rgba(0, 255, 255, 0.35)" },  // cyan
        { stroke: "rgba(0, 180, 255, 0.08)", glow: "rgba(0, 180, 255, 0.35)" },  // teal-blue
        { stroke: "rgba(140, 100, 255, 0.1)", glow: "rgba(140, 100, 255, 0.40)" }, // violet
        { stroke: "rgba(0, 255, 170, 0.08)", glow: "rgba(0, 255, 170, 0.35)" },  // aqua-green
        { stroke: "rgba(255, 140, 0, 0.07)", glow: "rgba(255, 140, 0, 0.32)" }   // amber
      ];

      const LINE_COUNT = 65;
      const lines = [];

      function createLine() {
        const len = 100 + Math.random() * 260;
        const speed = 120 + Math.random() * 220; // faster
        const thickness = 1 + Math.random() * 2;
        const color = LINE_COLORS[Math.floor(Math.random() * LINE_COLORS.length)];

        const startX = Math.random() * (width + height) - height;
        const startY = -len - Math.random() * height;

        return {
          x: startX,
          y: startY,
          len,
          speed,
          thickness,
          color,
          // Zigzag parameters
          wiggleAmp: 10 + Math.random() * 30,
          wiggleFreq: 8 + Math.random() * 18,
          wiggleSpeed: 4 + Math.random() * 8,
          phase: Math.random() * Math.PI * 2
        };
      }

      for (let i = 0; i < LINE_COUNT; i++) {
        lines.push(createLine());
      }

      let lastTime = performance.now();

      function loop(now) {
        const dt = (now - lastTime) / 1000;
        lastTime = now;

        // Fade previous frame slightly for motion trails
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = "rgba(0, 0, 0, 0.18)";
        ctx.fillRect(0, 0, width, height);

        ctx.globalCompositeOperation = "lighter";

        lines.forEach((line, idx) => {
          // Move diagonally: down + right (faster)
          const diagSpeed = line.speed;
          line.x += diagSpeed * dt * 0.7;
          line.y += diagSpeed * dt;
          line.phase += line.wiggleSpeed * dt;

          // If out of view, respawn above
          if (line.y - line.len > height || line.x - line.len > width) {
            lines[idx] = createLine();
            return;
          }

          const dx = line.len * 0.7;
          const dy = line.len;
          const segments = 12;

          ctx.save();
          ctx.strokeStyle = line.color.stroke;
          ctx.lineWidth = line.thickness;
          ctx.shadowColor = line.color.glow;
          ctx.shadowBlur = 18 + Math.random() * 10; // glowing
          ctx.beginPath();

          for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const baseX = line.x - dx * t;
            const baseY = line.y - dy * t;

            const wobble = line.wiggleAmp * Math.sin(line.phase + t * line.wiggleFreq);
            const px = baseX + wobble;
            const py = baseY + wobble * 0.35;

            if (i === 0) {
              ctx.moveTo(px, py);
            } else {
              ctx.lineTo(px, py);
            }
          }

          ctx.stroke();
          ctx.restore();
        });

        requestAnimationFrame(loop);
      }

      requestAnimationFrame(loop);
    })();

    /* ---------- Controller configurator logic ---------- */

    const BASE_WIDTH = 1166;
    const BASE_HEIGHT = 768;

    const PARTS = [
      { id: "psButton", mask: "masks/psButton.png", priority: 4 },
      { id: "share", mask: "masks/share.png", priority: 4 },
      { id: "options", mask: "masks/options.png", priority: 4 },
      { id: "speaker", mask: "masks/speaker.png", priority: 4 },
      { id: "dpad", mask: "masks/dpad.png", priority: 4 },
      { id: "faceButtons", mask: "masks/faceButtons.png", priority: 4 },
      { id: "stickL", mask: "masks/stickL.png", priority: 3 },
      { id: "stickR", mask: "masks/stickR.png", priority: 3 },
      { id: "touchpad", mask: "masks/touchpad.png", priority: 2 },
      { id: "bumperL", mask: "masks/bumperL.png", priority: 2 },
      { id: "bumperR", mask: "masks/bumperR.png", priority: 2 },
      { id: "centerBody", mask: "masks/centerBody.png", priority: 1 },
      { id: "leftShell", mask: "masks/leftShell.png", priority: 1 },
      { id: "rightShell", mask: "masks/rightShell.png", priority: 1 }
    ];

    const COLORS = [
      "#ffffff", "#f5f5f5", "#000000", "#cccccc", "#777777",
      "#00b0ff", "#ff4081", "#7c4dff", "#69f0ae",
      "#ff1744", "#ff9100", "#ffc400", "#2979ff", "#00e676"
    ];

    const controllerArea = document.getElementById("controllerArea");
    const paletteContainer = document.getElementById("paletteContainer");

    const layers = Array.from(document.querySelectorAll(".part-layer"));
    const layerById = {};
    layers.forEach(l => { layerById[l.dataset.partId] = l; });

    const maskDataById = {};
    let masksReady = false;

    function loadMask(part) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.src = part.mask;
        img.onload = () => {
          const canvas = document.createElement("canvas");
          canvas.width = img.naturalWidth;
          canvas.height = img.naturalHeight;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0);
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          maskDataById[part.id] = {
            width: canvas.width,
            height: canvas.height,
            data: imageData.data
          };
          resolve();
        };
        img.onerror = reject;
      });
    }

    // Load masks
    Promise.all(PARTS.map(loadMask)).then(() => {
      masksReady = true;
    }).catch(err => {
      console.error("Error loading masks:", err);
    });

    // Config state
    const configState = {};
    PARTS.forEach(p => { configState[p.id] = null; });

    let selectedPartId = null;

    function buildPalette() {
      paletteContainer.innerHTML = "";
      COLORS.forEach((color, i) => {
        const swatch = document.createElement("button");
        swatch.className = "swatch";
        swatch.style.background = color;
        swatch.style.animationDelay = `${i * 18}ms`;

        if (["#ffc400", "#ffea00", "#d4af37"].includes(color)) {
          swatch.classList.add("gold-rim");
        }

        swatch.addEventListener("click", (e) => {
          e.stopPropagation();
          if (!selectedPartId) return;
          applyColor(selectedPartId, color);
          clearSelection();
          hidePalette();
        });

        paletteContainer.appendChild(swatch);
      });
    }

    function showPalette() {
      buildPalette(); // rebuild each time to restart animations
      requestAnimationFrame(() => {
        paletteContainer.classList.add("visible");
      });
    }

    function hidePalette() {
      paletteContainer.classList.remove("visible");
    }

    function clearSelection() {
      if (!selectedPartId) return;
      const layer = layerById[selectedPartId];
      if (layer) layer.classList.remove("selected");
      selectedPartId = null;
    }

    function applyColor(partId, color) {
      configState[partId] = color;
      const layer = layerById[partId];
      if (!layer) return;
      layer.style.setProperty("--tint", color);
      layer.classList.add("apply-flash");
      layer.addEventListener("animationend", () => {
        layer.classList.remove("apply-flash");
      }, { once: true });
    }

    function hitTestPart(designX, designY) {
      const sorted = [...PARTS].sort((a, b) => b.priority - a.priority);

      for (const part of sorted) {
        const mask = maskDataById[part.id];
        if (!mask) continue;

        const x = Math.floor(designX / BASE_WIDTH * mask.width);
        const y = Math.floor(designY / BASE_HEIGHT * mask.height);
        if (x < 0 || y < 0 || x >= mask.width || y >= mask.height) continue;

        const idx = (y * mask.width + x) * 4 + 3;
        const alpha = mask.data[idx];
        if (alpha > 20) return part.id;
      }
      return null;
    }

    controllerArea.addEventListener("click", (e) => {
      if (!masksReady) return;

      const rect = controllerArea.getBoundingClientRect();
      const relX = (e.clientX - rect.left) / rect.width;
      const relY = (e.clientY - rect.top) / rect.height;

      if (relX < 0 || relX > 1 || relY < 0 || relY > 1) {
        hidePalette();
        clearSelection();
        return;
      }

      const designX = relX * BASE_WIDTH;
      const designY = relY * BASE_HEIGHT;

      const partId = hitTestPart(designX, designY);

      if (!partId) {
        hidePalette();
        clearSelection();
        return;
      }

      if (selectedPartId && selectedPartId !== partId) {
        const prevLayer = layerById[selectedPartId];
        if (prevLayer) prevLayer.classList.remove("selected");
      }

      selectedPartId = partId;
      const layer = layerById[partId];
      if (layer) layer.classList.add("selected");

      showPalette();
    });

    // Click outside controller & palette clears everything
    document.addEventListener("click", (e) => {
      if (!controllerArea.contains(e.target) && !paletteContainer.contains(e.target)) {
        hidePalette();
        clearSelection();
      }
    });
  </script>
</body>

</html>
